[{"categories":null,"content":"回忆了一下自己学计算机的动机，果然还是想做游戏。写引擎看起来也够有挑战性够有意思。 游戏引擎离不开图形学API，现有的api我都没什么了解。 于是决定今天起开始系统学习。用作笔记，如果学习轨迹能帮助后来者，也是好的。 ","date":"2020-10-31","objectID":"/directx-from-0/:0:0","tags":["Computer Graphics","DirectX12"],"title":"从0开始学Direct X12","uri":"/directx-from-0/"},{"categories":null,"content":"为什么要学习DirectX 12？ DirectX12, OpenGL, Vulkan, Metal, WebGL都是现在常用的low level图形API (Low level Graphics APIs) 其中OpenGL历史较久，API较旧，与现代GPU架构提供的接口有差距，比如它使用了一个全局的状态机（single global state machine）来表示状态。DirectX 12相比OpenGL更接近现代GPU架构。而且DirectX12、Vulkan和Metal。不过目前的Android机器大部分只兼容OpenGL ES，iOS则是Metal为主 Vulkan 目前来看，细节复杂，对于我这种初学者来说学习难度可能很大，暂且搁置。 加上DX12我能找到较多的资料，加上手上的计算平台也是windows的，所以最后就选择 DX12 作为上手了。 从理性来看，图形API该学都是要学的， ","date":"2020-10-31","objectID":"/directx-from-0/:1:0","tags":["Computer Graphics","DirectX12"],"title":"从0开始学Direct X12","uri":"/directx-from-0/"},{"categories":null,"content":"入门学习计划 计划先过一遍https://github.com/microsoft/DirectX-Graphics-Samples 下的sample作为实践。 结合Frank Luna 的 Introduction to 3D Game Programming with DirectX 12 作为教材 ","date":"2020-10-31","objectID":"/directx-from-0/:2:0","tags":["Computer Graphics","DirectX12"],"title":"从0开始学Direct X12","uri":"/directx-from-0/"},{"categories":null,"content":"学习进度 书前三章概括： 线性代数复习+DirectX接口科普 一些备忘： XMVECTOR 是DirectX12提供的vector类型，由4个float组成，本质是__m128类型。 XM_CALLCONV 是DirectX用来帮助指定编译器用什么function call convention的修饰符（例如__fastcall和__vectorcall)。__fastcall在调用函数传参时，32位windows会在pass __m128时，把前三个__m128类型的参数给直接传给SSE/SSE2的寄存器，剩下的参数压倒栈里，64位会直接都压进栈。而__vectorcall会把前6个__m128参数直接传给SSE/SSE2寄存器。传参给寄存器显然比直接压栈快。 来源：https://docs.microsoft.com/en-us/windows/win32/dxmath/pg-xnamath-internals 注意XMVECTOR作为参数时，为了性能，需要让参数类型按照一定顺序排列： FXMVECTOR 前三个参数类型 GXMVECTOR 第四个 HXMVECTOR 第五个第六个 CXMVECTOR 之后更多 为什么是这样安排，暂时不了解，以后再来探索吧 叉积（cross product）的结果一般是右手系（right hand rule）的，就是如果你想计算$a\\times b$，那么拿出右手食指对准a的方向，中指对准b的方向，结果会指向大拇指。（我自己老是忘是左手还是右手，2d是顺时针还是逆时针） 3d向量加一个维度变成齐次坐标，相关的矩阵变换（例如scale，translate，project）要会推导。 值得注意的是DirectX使用row vector 来做矩阵乘法，这个似乎和OpenGL是反着的，所以如果按照column vector来写变换矩阵的话，得到的会是目标matrix的转置： $$\\left[\\begin{array}{llll} x^{\\prime} \u0026 y^{\\prime} \u0026 z^{\\prime} \u0026 w^{\\prime} \\end{array}\\right]=\\left[\\begin{array}{llll} x \u0026 y \u0026 z \u0026 w \\end{array}\\right]\\left[\\begin{array}{llll} m 11 \u0026 m 12 \u0026 m 13 \u0026 m 14 \\\\ m 21 \u0026 m 22 \u0026 m 23 \u0026 m 24 \\\\ m 31 \u0026 m 32 \u0026 m 33 \u0026 m 34 \\\\ m 41 \u0026 m 42 \u0026 m 43 \u0026 m 44 \\end{array}\\right]$$ 书第四章： 未完待续。。。 Matrix A,B A: 3 row 5 column B: 5 rows 4 columns C[A] == R[B] A x B for i = 1 to row[A] for j = 1 to col[B] for k = 1 to col[A](row[B]) C[i][j] += A[i][k]*B[k][j] to do a matrix mulplication AxB : you need column A match row B the cost of multiplication AxB is row[A]*col[A]*col[B] M[i] : ith matrix M[i] : d[i] rows d[i+1] columns N = 3 M[1] * M[2] * M[3] d = [_ ,_ _ , _,_ ] AxB: row[A] rows, col[B] columns D = A x B E = D x C return E the number of mulplication performed: (A x B) x C row[A]*col[A]*col[B] + row[A]*col[B]*col[C] = d[1]*d[2]*d[3] + d[1]*d[3]*d[4] A x (B X C) row[B]*col[B]*col[C] + row[A]*col[A]*col[C] = d[2]*d[3]*d[4] + d[1]*d[2]*d[4] AxBxC row[A] = d[1] col[A] = d[2] row[B]= d[2] col[B] =d[3] Goal : (M[i]xM[i+1]x…M[j]) (M[i]x M[i+1]x .. M[k]) x (M[k+1]xM[k+2]x…M[j]) L = (M[i]x M[i+1]x .. M[k]) R = (M[k+1]xM[k+2]x…M[j]) Best(i,j) = least number for M[i]x…xM[j] Cost(i,j)==Best(j, i+j) Cost[0,1] = 0 Cost[0,2 ] =0 , Cost[0,3]=0 Cost[0,4]=0 Cost[1,1]=Best[1,2] Cost[1,2]=Best[2,3] Cost[2,1] = Best[1,3] Best[1,10] -\u003e Best[1,5] + Best[6,10] Best[1,10] -\u003e Best[1,7] + Best[8, 10] Best[1,7] -\u003e Best[1,5] + Best[6,7] Best[1,5] is child of Best[1,7] and also child of Best[1,10] recover solution n\u003c=100 A[1..m] B[1..n] Look[1..m,1..n] string FindS(int i, int j) if i==0 or j==0: return \"\" if A[i]==B[j] and Look[i,j]==Look[i-1,j-1]+1 return FindS(i-1,j-1) + A[i] if Look[i-1,j]==Look[i,j] return FindS(i-1,j) return FindS(i,j-1) FindS(m,n) Cost[i,j] : the least number of product you need to get products from M[j] to M[i+j] Cost[i,j] = Best[j.i+j] Cost[i,j] = m (M[j]x..xM[k])x(M[k+1]x...xM[i+j]) $$Cost[i,j] = \\min_{k=j}^{i+j} Best[j,k]+Best[k+1,i+j]\\\\ Cost[i,j]=\\min_{k=j}^{i+j} Cost[k-j,j] + Cost[i+j-(k+1),k+1]\\\\ Cost[i,j]=\\min_{k=1}^{i-1} Cost[k,j] + Cost[i-k,j+k]\\\\ $$ cutting the wood S[1..n] S[i] : size of restaurant i 4 5 7 2 6 -\u003e 4 (5+7) 2 6 -\u003e 4 12 2 6 cost 7 [1,k] [k+1,n] Best[i,j] optimal cost to merge i, i+1,.. ,j into 1 restaurant goal is find Best[1,n] [i, i+1,.. ,k ] [k+1,…, j] sum[i,j] = sum of size from i.. to j sum[i,j] = 0 if i\u003ej sum[i,j] = S[i] if i==j sum[i,j] = sum[i,j-1] + S[j] if i\u003cj Best[i,j] = min{ max(sum[i,k], sum[k+1,j] ) + Best[i,k] + Best[k+1,j] | i \u003c= k \u003c j} sum[i.k] Look[i,j] = GCS(i,j) length of greatest common subsequence for A[1..i] B[1..j] you need to print string S which has length Look[n,m] and S must be a subsequence of both A and B function Print(i,j): ​ {print string S which has length Look[i,j] and S must be a subsequence of both A[1..i] and B[1..j]} ​ if i==0 or j==0: ​ return ​ endif ​ if A[i] == B[j] and Look[i,j] == Look[i-1,j-1] then ​ Print(i-1,j-1) ​ Print(A[i]) ​ endif ​ if Look[i-1,j] == Look[i,j]: ​ Print(i-1,j) ​ endif ​ if Look[i,j-1] == Look[i,j] ​ Print(i,j-1) ​ endif endfunc ​ G: u-\u003ev 1 to 5 1-\u003e3-\u003e5 For each pair of edges in G: (u-\u003ev, len1), (v-\u003ew, len2) ","date":"2020-10-31","objectID":"/directx-from-0/:3:0","tags":["Computer Graphics","DirectX12"],"title":"从0开始学Direct X12","uri":"/directx-from-0/"},{"categories":null,"content":"写一写最近学到的东西和笔记 ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于这个博客","uri":"/about/"}]